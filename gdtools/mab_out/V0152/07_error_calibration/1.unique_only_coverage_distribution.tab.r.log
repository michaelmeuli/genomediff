
R version 4.2.3 (2023-03-15) -- "Shortstop Beagle"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-conda-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##
> ##
> ## AUTHORS
> ##
> ## Jeffrey E. Barrick <jeffrey.e.barrick@gmail.com>
> ##
> ## LICENSE AND COPYRIGHT
> ##
> ## Copyright (c) 2008-2010 Michigan State University
> ## Copyright (c) 2011-2022 The University of Texas at Austin
> ##
> ## breseq is free software; you can redistribute it and/or modify it under the
> ## terms the GNU General Public License as published by the Free Software
> ## Foundation; either version 1, or (at your option) any later version.
> ##
> ##
> 
> ## Arguments:
> ##   distribution_file=/path/to/input 
> ##   plot_file=/path/to/output 
> ##   deletion_propagation_pr_cutoff=float
> ##   plot_poisson=0 or 1
> ##   pdf_output=0 or 1
> 
> ## Returns these values printed out to output log
> ## 
> ##  1. print(nb_fit_size); # 0 if fit failed
> ##  2. print(nb_fit_mu);   # 0 if fit failed
> ##  3. print(m)q
> ##  4. print(v)
> ##  5. print(D)
> ##  6. print(deletion_propagation_coverage)
> ##     -1 if it was <1 after fitting (implying reference sequence is deleted)
> ##
> 
> plot_poisson = 0;
> pdf_output = 1;
> 
> this.print.level = 0
> #this.print.level = 2
> 
> for (e in commandArgs(TRUE)) {
+   ta = strsplit(e,"=",fixed=TRUE)[[1]]
+   if(length(ta)>1) {
+     temp = ta[2]
+     assign(ta[1],temp)
+     cat("assigned ",ta[1]," the value of |",temp,"|\n")
+   } else {
+     assign(ta[[1]][1],TRUE)
+     cat("assigned ",ta[1]," the value of TRUE\n")
+   }
+ }
assigned  distribution_file  the value of | /scratch/mpanza/breseq/mab/V0152/07_error_calibration/1.unique_only_coverage_distribution.tab |
assigned  plot_file  the value of | /scratch/mpanza/breseq/mab/V0152/output/calibration/1.unique_coverage.pdf |
assigned  deletion_propagation_pr_cutoff  the value of | 0.000327427 |
> 
> deletion_propagation_pr_cutoff = as.numeric(deletion_propagation_pr_cutoff);
> 
> ## initialize values to be filled in
> nb_fit_mu = 0
> nb_fit_size = 0
> m = 0
> v = 0
> D = 0
> deletion_propagation_coverage = -1
> 
> min_fraction_included_in_nb_fit = 0.01
> 
> #load data
> X<-read.table(distribution_file, header=T)
> 
> #table might be empty
> if (nrow(X) == 0)
+ {
+   #print out statistics
+   
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> #create the distribution vector and fit
> Y<-rep(X$coverage, X$n)
> m<-mean(Y)
> v<-var(Y)
> D<-v/m
> 
> ###
> ## Smooth the distribution with a moving average window of size 5
> ## so that we can more reliably find it's maximum value
> ###
> 
> ma5 = c(1, 1, 1, 1, 1)/5;
> 
> ## filtering fails if there are too few points
> if (nrow(X) >= 5) {
+   X$ma = filter(X$n, ma5)
+ } else {
+ 	X$ma = X$n
+ }
> 
> i<-0
> max_n <- 0;
> min_i <- max( trunc(m/4), 1 ); #prevents zero for pathological distributions
> max_i <- i;
> for (i in min_i:length(X$ma))
+ {		
+   #cat(i, "\n")
+ 	if (!is.na(X$ma[i]) && (X$ma[i] > max_n))
+ 	{
+ 		max_n = X$ma[i];
+ 		max_i = i;
+ 	}
+ }
> 
> ##
> # Censor data on the right and left of the maximum
> ##
> 
> start_i = max(floor(max_i*0.5), 1);
> end_i = min(ceiling(max_i*1.5), length(X$ma));
> 
> if (start_i == end_i)
+ {
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> cat("Fitting from coverage of ", start_i, " to ", end_i, ".\n", sep="")
Fitting from coverage of 79 to 237.
> 
> ##
> # Coarse grain so that we are only fitting a number of bins that is 1000-2000
> #
> # The later adjustment for doing the fits this way is to multiply the means
> # of the negative binomial and poisson distributions by the binning number.
> # (The size parameter of the negative binomial doesn't need to be adjusted.)
> ##
> 
> 
> num_per_bin = trunc((end_i - start_i) / 1000)
> 
> if (num_per_bin > 1) 
+ {
+   cat("Coarse-graining for fits\n")
+   start_i_for_fits = trunc(start_i/num_per_bin)
+   end_i_for_fits = ceiling(end_i/num_per_bin)
+   num_bins = end_i - start_i  + 1
+   cat("Fitting from coverage in adjusted bins ", start_i_for_fits, " to ", end_i_for_fits, ".\n", sep="")
+   cat("Number of bins ", num_bins, ". Each bin has ", num_per_bin, " coverage values.\n", sep="")
+ 
+   # Create a new vector where we've added together values in bins
+   X.for.fits = vector("double", end_i_for_fits)
+   for (i in start_i_for_fits:end_i_for_fits)
+   {
+     for (j in 1:num_per_bin)
+     {
+       if (i*num_per_bin+j <= length(X$n))
+       {
+         X.for.fits[i] = X.for.fits[i] + X$n[i*num_per_bin+j]
+       }
+     }
+   }
+ 
+ } else {
+   ## AVOID num_per_bin equalling zero!!
+   X.for.fits = X$n[1:end_i]
+   num_per_bin = 1
+   start_i_for_fits = start_i
+   end_i_for_fits = end_i
+ }
> 
> 
> ##
> # Now perform negative binomial fitting to the censored data
> ##
> 
> inner_total<-0;
> for (i in start_i_for_fits:end_i_for_fits)
+ {
+ 	inner_total = inner_total + X.for.fits[i]; 
+ }
> # Yes: it's correct to use X here because we want the overall total total
> total_total<-sum(X$n);
> 
> ## let's preconstruct these for speed
> dist = vector("double", end_i_for_fits)
> 
> f_nb <- function(par) {
+ 
+ 	mu = par[1];
+ 	size = par[2];
+ 
+   if ((mu <= 0) || (size <= 0))
+   {
+     return(0);
+   }
+   
+   cat(start_i_for_fits, " ", end_i_for_fits, "\n");
+   cat(mu, " ", size, "\n");
+   
+ 	dist<-c()
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+ 		dist[i] <- dnbinom(i, size=size, mu=mu);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (mu, size)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> 
> ## Fit negative binomial 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> nb_fit = NULL
> ## as.numeric prevents overflow in sums involving integers
> mean_estimate = sum((as.numeric(1:end_i_for_fits)*as.numeric(X.for.fits)))/sum(as.numeric(X.for.fits))
> 
> nb_fit_mu = -1
> nb_fit_size = -1
> try_size = 100000
> try_means_index = 1
> #This is a list of different means to test <-  sometimes the actual mean doesn't lead to a fit
> try_means = c(mean_estimate, 
+               end_i_for_fits, 
+               start_i_for_fits, 
+               1*(end_i_for_fits + start_i_for_fits)/4,
+               2*(end_i_for_fits + start_i_for_fits)/4,
+               3*(end_i_for_fits + start_i_for_fits)/4
+               )
>               
>               
> nb_fit = c()
> 
> while ( ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1)) && (try_size > 0.001) && (try_means_index <= length(try_means)))
+ {
+   try_size = try_size / 10
+   try_mean = try_means[try_means_index]
+ 
+   ## SIZE ESTIMATE from the censored data can be negative, so try various values instead
+   cat("Try Mean: ", try_mean, " Size: ", try_size, "\n")
+ 
+   try( suppressWarnings(nb_fit<-nlm(f_nb, c(try_mean, try_size), iterlim=1000, print.level=this.print.level)) )
+ 
+   nb_fit_mu = nb_fit$estimate[1];
+   nb_fit_size = nb_fit$estimate[2];
+ 
+   cat("Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, "\n")
+   
+   if (try_size <= 0.001) {
+     try_size = 100000
+     try_means_index = try_means_index + 1
+   }
+ }
Try Mean:  116.3545  Size:  10000 
79   237 
116.3545   10000 
79   237 
116.3545   10000 
79   237 
116.3546   10000 
79   237 
116.3545   10000.01 
79   237 
116.3548   10000 
79   237 
116.3549   10000 
79   237 
116.3548   10000.01 
79   237 
127.6875   9999.999 
79   237 
127.6877   9999.999 
79   237 
127.6875   10000.01 
79   237 
130.6779   9999.999 
79   237 
130.678   9999.999 
79   237 
130.6779   10000.01 
79   237 
146.1135   9999.994 
79   237 
146.1137   9999.994 
79   237 
146.1135   10000 
79   237 
181.0257   9999.986 
79   237 
151.6741   9999.993 
79   237 
151.6743   9999.993 
79   237 
151.6741   10000 
79   237 
153.3785   9999.992 
79   237 
153.3786   9999.992 
79   237 
153.3785   10000 
79   237 
152.7184   9999.992 
79   237 
152.7185   9999.992 
79   237 
152.7184   10000 
79   237 
152.7472   9999.992 
79   237 
152.7473   9999.992 
79   237 
152.7472   10000 
79   237 
152.7479   9999.991 
79   237 
152.7481   9999.991 
79   237 
152.7479   10000 
79   237 
152.7481   9999.991 
79   237 
152.7483   9999.991 
79   237 
152.7481   10000 
79   237 
152.7491   9999.985 
79   237 
152.7493   9999.985 
79   237 
152.7491   9999.995 
79   237 
152.7503   9999.971 
79   237 
152.7504   9999.971 
79   237 
152.7503   9999.981 
79   237 
152.7524   9999.929 
79   237 
152.7526   9999.929 
79   237 
152.7524   9999.939 
79   237 
152.7557   9999.817 
79   237 
152.7559   9999.817 
79   237 
152.7557   9999.827 
79   237 
152.7612   9999.511 
79   237 
152.7613   9999.511 
79   237 
152.7612   9999.521 
79   237 
152.7699   9998.702 
79   237 
152.7701   9998.702 
79   237 
152.7699   9998.712 
79   237 
152.7841   9996.557 
79   237 
152.7843   9996.557 
79   237 
152.7841   9996.567 
79   237 
152.8071   9990.904 
79   237 
152.8073   9990.904 
79   237 
152.8071   9990.914 
79   237 
152.8444   9976.005 
79   237 
152.8445   9976.005 
79   237 
152.8444   9976.015 
79   237 
152.9051   9936.658 
79   237 
152.9053   9936.658 
79   237 
152.9051   9936.668 
79   237 
153.0058   9831.763 
79   237 
153.006   9831.763 
79   237 
153.0058   9831.773 
79   237 
153.1808   9544.329 
79   237 
153.181   9544.329 
79   237 
153.1808   9544.339 
79   237 
153.5321   8683.386 
79   237 
153.5322   8683.386 
79   237 
153.5321   8683.395 
79   237 
154.8312   4603.499 
79   237 
154.8313   4603.499 
79   237 
154.8312   4603.504 
Fit Mean:  160.2723  Size:  -12031.74  Code:  1 
Try Mean:  116.3545  Size:  1000 
79   237 
116.3545   1000 
79   237 
116.3545   1000 
79   237 
116.3546   1000 
79   237 
116.3545   1000.001 
79   237 
116.3548   1000 
79   237 
116.3549   1000 
79   237 
116.3548   1000.001 
79   237 
129.0209   999.9262 
79   237 
129.021   999.9262 
79   237 
129.0209   999.9272 
79   237 
133.4774   999.8528 
79   237 
133.4775   999.8528 
79   237 
133.4774   999.8538 
79   237 
137.9436   999.7758 
79   237 
137.9438   999.7758 
79   237 
137.9436   999.7768 
79   237 
143.688   999.6895 
79   237 
143.6881   999.6895 
79   237 
143.688   999.6905 
79   237 
149.9937   999.6024 
79   237 
149.9938   999.6024 
79   237 
149.9937   999.6034 
79   237 
153.4834   999.5181 
79   237 
153.4835   999.5181 
79   237 
153.4834   999.5191 
79   237 
151.7101   999.5227 
79   237 
151.7103   999.5227 
79   237 
151.7101   999.5237 
79   237 
151.8321   999.4844 
79   237 
151.8323   999.4844 
79   237 
151.8321   999.4854 
79   237 
151.8522   999.4365 
79   237 
151.8523   999.4365 
79   237 
151.8522   999.4375 
79   237 
151.9316   999.0387 
79   237 
151.9317   999.0387 
79   237 
151.9316   999.0397 
79   237 
152.0308   998.0691 
79   237 
152.031   998.0691 
79   237 
152.0308   998.0701 
79   237 
152.2087   994.9949 
79   237 
152.2089   994.9949 
79   237 
152.2087   994.9959 
79   237 
152.4869   986.7113 
79   237 
152.4871   986.7113 
79   237 
152.4869   986.7123 
79   237 
152.96   963.1709 
79   237 
152.9601   963.1709 
79   237 
152.96   963.1719 
79   237 
153.8289   893.9868 
79   237 
153.8291   893.9868 
79   237 
153.8289   893.9877 
79   237 
156.1638   630.502 
79   237 
156.1639   630.502 
79   237 
156.1638   630.5027 
79   237 
158.4726   323.9853 
79   237 
158.4727   323.9853 
79   237 
158.4726   323.9856 
Fit Mean:  174.4802  Size:  -1365.687  Code:  1 
Try Mean:  116.3545  Size:  100 
79   237 
116.3545   100 
79   237 
116.3545   100 
79   237 
116.3546   100 
79   237 
116.3545   100.0001 
79   237 
116.3548   99.99996 
79   237 
116.3549   99.99996 
79   237 
116.3548   100.0001 
79   237 
138.2657   94.96474 
79   237 
138.2658   94.96474 
79   237 
138.2657   94.96484 
79   237 
144.6005   90.99951 
79   237 
144.6007   90.99951 
79   237 
144.6005   90.9996 
79   237 
144.9106   88.03786 
79   237 
144.9108   88.03786 
79   237 
144.9106   88.03795 
Fit Mean:  493.7547  Size:  -4086.234  Code:  1 
Try Mean:  116.3545  Size:  10 
79   237 
116.3545   10 
79   237 
116.3545   10 
79   237 
116.3546   10 
79   237 
116.3545   10.00001 
79   237 
116.3546   9.999936 
79   237 
116.3547   9.999936 
79   237 
116.3546   9.999946 
79   237 
124.777   8.614153 
79   237 
124.7771   8.614153 
79   237 
124.777   8.614162 
79   237 
133.3154   11.00266 
79   237 
133.3155   11.00266 
79   237 
133.3154   11.00267 
79   237 
141.1989   14.83915 
79   237 
141.1991   14.83915 
79   237 
141.1989   14.83916 
79   237 
138.0118   14.3893 
79   237 
138.0119   14.3893 
79   237 
138.0118   14.38931 
79   237 
136.8373   15.21772 
79   237 
136.8374   15.21772 
79   237 
136.8373   15.21774 
79   237 
136.5096   16.75834 
79   237 
136.5097   16.75834 
79   237 
136.5096   16.75836 
79   237 
136.94   17.42928 
79   237 
136.9401   17.42928 
79   237 
136.94   17.4293 
79   237 
137.0576   17.57214 
79   237 
137.0578   17.57214 
79   237 
137.0576   17.57216 
79   237 
137.0574   17.576 
79   237 
137.0575   17.576 
79   237 
137.0574   17.57601 
Fit Mean:  137.0574  Size:  17.576  Code:  1 
> 
> cat("Final Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, " Try Size: ", try_size, "\n")
Final Fit Mean:  137.0574  Size:  17.576  Code:  1  Try Size:  10 
> 
> ## Fit failed = reset parameters so graphing and output code can recognize this
> if ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1))
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> 
> ## things can go wrong with fitting and we can still end up with invalid values
> 
> fit_nb = c()
> included_fract = 0
> if (nb_fit_mu > 0)
+ {
+   end_fract = pnbinom(end_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   start_fract = pnbinom(start_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   included_fract = end_fract-start_fract;
+ 
+   if (included_fract >= 0.01) {
+ 
+     ## Adjust so that we are back in full coords before making fit!!
+     if (num_per_bin > 1) 
+     {
+       nb_fit_mu = nb_fit_mu * num_per_bin
+     }
+     fit_nb = dnbinom(0:max(X$coverage), mu = nb_fit_mu, size=nb_fit_size)*inner_total/included_fract;
+   }
+ }
> 
> ## If an insufficient amount of fit was included, then invalidate it
> if (included_fract < 0.01)
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> f_p <- function(par) {
+ 
+   lambda = par[1];
+ 
+   if (lambda <= 0)
+   {
+     return(0);
+   }
+   
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+     #cat(i, " ", lambda, "\n");
+ 		dist[i] <- dpois(i, lambda=lambda);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (total)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> ## Fit Poisson 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> 
> p_fit = NULL
> try(suppressWarnings(p_fit<-nlm(f_p, c(m), print.level=this.print.level)))
> 
> fit_p = c()
> if (!is.null(p_fit) && (p_fit$estimate[1] > 0))
+ {
+   #print (nb_fit$estimate[1])
+   p_fit_lambda = p_fit$estimate[1];
+   #print(0:max(X$coverage))
+ 
+   end_fract = ppois(end_i_for_fits, lambda = p_fit_lambda)
+   start_fract = ppois(start_i_for_fits, lambda = p_fit_lambda)
+   included_fract = end_fract-start_fract;
+ 
+   ## Adjust so that we are back in full coords before making fit!!
+   if (num_per_bin > 1) 
+   {
+     p_fit_lambda = p_fit_lambda * num_per_bin
+   }
+   fit_p<-dpois(0:max(X$coverage), lambda = p_fit_lambda)*inner_total/included_fract;
+ }
> 
> 
> ## Graphing
> ##
> ## don't graph very high values with very little coverage
> i<-max_i
> while (i <= length(X$n) && X$n[i]>0.01*max_n)
+ {		
+ 	i <- i+1;
+ }
> graph_end_i <-i
> 
> ## Ths leaves enough room to the right of the peak for the legend
> graph_end_i = max(floor(2.2 * max_i), graph_end_i);
> 
> ## graphics settings
> my_pch = 21
> my_col = "black";
> my_col_censored = "red";
> 
> if (pdf_output == 0) {
+   
+   ## bitmap() requires ghostscript to be installed.
+   ## taa=4, gaa=2 options NOT compatible with earlier R versions!
+   ## units = "px" NOT compatible with even earlier R versions!
+   
+   if(!capabilities(what = "png"))
+   {
+     ## fallback to ghostscript
+     bitmap(plot_file, height=6, width=7, type = "png16m", res = 72, pointsize=18)
+   } else {
+     ## use X11 function, which gives better resolution
+     png(plot_file, height=6, width=7, units ="in", res = 72, pointsize=18)
+     par(family="sans")
+   }
+ } else {
+   pdf(plot_file, height=6, width=7)
+   par(family="sans")
+ }
> 
> par(mar=c(5.5,7.5,3,1.5));
> 
> max_y = 0
> if (plot_poisson) {
+ 	max_y = max(X$n, fit_p, fit_nb)
+ } else {
+ 	max_y = max(X$n, fit_nb)
+ }
> 
> plot(0:10, 0:10, type="n", lty="solid", ylim=c(0, max_y)*1.05, xlim=c(0, graph_end_i), lwd=1, xaxs="i", yaxs="i", axes=F, las=1, main="Coverage Distribution at Unique-Only Positions", xlab="Coverage depth (reads)", ylab="", cex.lab=1.2, cex.axis=1.2)
> 
> mtext(side = 2, text = "Number of reference positions", line = 5.5, cex=1.2)
> 
> sciNotation <- function(x, digits = 1) {
+     if (length(x) > 1) {
+         return(append(sciNotation(x[1]), sciNotation(x[-1])))     
+ 	} 
+     if (!x) return(0) 
+ 
+ 	exponent <- floor(log10(x)) 
+     base <- round(x / 10^exponent, digits)     
+ 	as.expression(substitute(base %*% 10^exponent, list(base = base, exponent = exponent))) 
+ }
> 
> #axis(2, cex.lab=1.2, las=1, cex.axis=1.2, labels=T, at=(0:6)*50000)
> axis(2, cex.lab=1.2, las=1, cex.axis=1.2, at = axTicks(2), labels = sciNotation(axTicks(2), 1))
> axis(1, cex.lab=1.2, cex.axis=1.2, labels=T)
> box()
> 
> #graph the coverage as points
> fit_data <- subset(X, (coverage>=start_i) & (coverage<=end_i) );
> points(fit_data$coverage, fit_data$n, pch=my_pch, col=my_col, bg="white", cex=1.2)
> 
> #graph the censored coverage as red points
> cat(start_i, " ", end_i, "\n", sep="")
79 237
> 
> censored_data <- subset(X, (coverage<start_i) | (coverage>end_i) );
> points(censored_data$coverage, censored_data$n, pch=my_pch, col=my_col_censored, bg="white", cex=1.2)
> 
> #graph the poisson fit IF REQUESTED
> if (plot_poisson) {
+ 	lines(0:max(X$coverage), fit_p, lwd=3, lty="22", col="black");
+ }
> 
> #graph the negative binomial fit
> if (nb_fit_mu > 0) {
+   lines(0:max(X$coverage), fit_nb, lwd=3, col="black");
+ }
> 
> if (plot_poisson) {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial", "Poisson"), lty=c("blank","blank","solid","22"), lwd=c(1,1,2,2), pch=c(my_pch, my_pch, -1, -1), col=c("black", "red", "black", "black"), bty="n")
+ } else {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial"), lty=c("blank","blank","solid"), lwd=c(1,1,2), pch=c(my_pch, my_pch, -1), col=c("black", "red", "black"), bty="n")
+ }
> 
> dev.off()
null device 
          1 
> 
> ## Fit the marginal value that we use for propagating deletions
> 
> if (nb_fit_mu > 0) {
+   cat(nb_fit_size, " ", nb_fit_mu, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = nb_fit_size, mu = nb_fit_mu))
+ } else {
+   cat("Fallback to calculating off an estimate of just variance = mu + mu^2/size\n")
+   size_estimate = (1/(v-m))*(m*m)
+   cat("Mu estimate=", m," Size estimate =", size_estimate, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = size_estimate, mu = m))
+   if (is.na(deletion_propagation_coverage) || is.nan(deletion_propagation_coverage) || (deletion_propagation_coverage < 1)) {
+     cat("Double fallback to calculating as just 10% of the mean\n")
+     deletion_propagation_coverage = m * 0.1
+   }
+ }
17.576   137.0574 
> 
> #Don't allow one read to indicate non-deleted regions
> if (deletion_propagation_coverage < 1) {
+     deletion_propagation_coverage = 1
+ }
> 
> #This works fine with the negative values
> #If we have both low fit coverage and low straight average coverage then we're deleted...
> if ( (nb_fit_mu <= 3) && (m <= 3) ) {
+   deletion_propagation_coverage = -1
+ }
> 
> #print out statistics
> 
> print(nb_fit_size);
[1] 17.576
> print(nb_fit_mu);
[1] 137.0574
> 
> print(m)
[1] 116.4215
> print(v)
[1] 1949.54
> print(D)
[1] 16.74554
> 
> print(deletion_propagation_coverage)
[1] 47
> 
> warnings()
> 
